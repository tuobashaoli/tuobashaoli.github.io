---
title: "leetcode"
layout: post
date: "2020-01-20 14:48:18"
categories: blog
published: True
tags: "leetcode"
---

### 无重复字符的最长子串的长度

用临时StringBuffer存储最长子串，如果遇到重复的字符，将已存储的最长子串中的重复位置前的部分全部删除，并记录此时的长度，时间复杂度是O(n),空间复杂度O(n)

```python
def getuniqsub(s):
    i=0
    j=0
    res = ""
    while j < len(s):
        # print(s[i:j])
        if s[j] not in s[i:j]:
            j += 1
            if j == len(s):
                if j - i > len(res):
                    res = s[i:j]
        else:
            if j - i > len(res):
                res = s[i:j]
            i = i + s[i:j].index(s[j]) + 1
    return res
```

### 最长公共前缀


### 非空个位数链表相加


```java
 public static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) { val = x; }
    }

 public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
           int tag = 0;
        ListNode ret = new ListNode(0);
        ListNode hehe = ret;
        while (l1 != null || l2 != null){
            if (l1 ==null){
                ret.val = (l2.val + tag)%10;
                tag = ( l2.val + tag)/10;
                l2 = l2.next;
            }else if (l2 == null){
                ret.val = (l1.val + tag)%10;
                tag = ( l1.val + tag)/10;
                l1 = l1.next;
            }else{
                ret.val = (l1.val + l2.val + tag)%10;
                tag = (l1.val + l2.val + tag)/10;
                l1 = l1.next;
                l2 = l2.next;
            }
            if (l1 == null && l2 == null ){
                if (tag == 1){
                    ret.next = new ListNode(1);
                    ret = ret.next;
                }else {
                    ret.next = null;
                }

            }else {
                ret.next = new ListNode(0);
                ret = ret.next;
            }

        }


        return hehe;
    }
```

### 盛水最多的容器

双指针,设置头指针和为指针，关键思路是找到俩端哪个高度更低，那么就挪动那个端的值，更加有可能找到更大的面积，因为面积取决于低的高度和横坐标之间的长度的乘积。


```java
  public int maxArea(int[] height) {
        int maxarea = 0,l=0,r=height.length-1;
        while(l<r){
            maxarea = Math.max(maxarea,Math.min(height[l],height[r])*(r-l));
            if(height[l] < height[r]){
                l++;
            }else{
                r--;
            }
        }
        return maxarea;
    }
```

### 最小覆盖字串

滑动窗口，当窗口右边界不断滑动，从而覆盖了目标子串中的所有元素时，收缩左边界，直到窗口刚刚覆盖目标字串，记录此时的窗口大小，然后将左窗口再收缩一个字符，并且更新是否覆盖字串的标记，继续滑动

```python
import  collections
def minWindow( s: str, t: str) -> str:
    need=collections.defaultdict(int)
    for c in t:
        need[c]+=1
    needCnt=len(t)
    i=0
    res=(0,float('inf')) #0和无穷大
    for j,c in enumerate(s):
        if need[c]>0:
            needCnt-=1
        need[c]-=1
        if needCnt==0:       #步骤一：滑动窗口包含了所有T元素
            while True:      #步骤二：增加i，排除多余元素
                c=s[i]
                if need[c]==0: #表示c这个字符属于t
                    break
                need[c]+=1 #表示c这个字符不属于t，继续找下一个字符
                i+=1
            if j-i<res[1]-res[0]:   #记录结果
                res=(i,j)
            need[s[i]]+=1  #步骤三：i增加一个位置，寻找新的满足条件滑动窗口
            needCnt+=1
            i+=1
    return '' if res[1]>len(s) else s[res[0]:res[1]+1]    #如果res始终没被更新过，代表无满足条件的结果
```

### 单向链表寻找中间节点

快慢双指针，快指针遍历到末尾的时候，慢指针就是到中间节点

```
class Node():

    def __init__(self, val):
        self.val = val
        self.next = None

# 单向链表中间节点
def findmid(node):
    first = node
    second = node
    while first and first.next:
        #print(first.val)
        first = first.next.next
        second = second.next
    return second.val
```

### 最多颜色的车辆

滑动窗口，每次移动窗口的时候，只需要比较新加入的元素的个数和之前记录的最多值


```python
def maxColor(color, win):
    count = {
        "0":0,
        "1":0,
        "2":0
    }
    l =0
    r = l + win
    for c in color[l:r]:
        count[c] += 1
    maxV = max(count.values())
    while r < len(color):
        add = color[r]
        remove = color[l]
        l += 1
        r +=1
        count[add]+=1
        count[remove]-=1
        maxV = max(maxV,count[add])
    return maxV
```

### 数位DP

###  电话号码字母组合

使用回溯算法，套公式即可

```python
def letterCombinations(digits):
    n_dict ={
        "2":["a","b","c"],
        "3":["d","e","f"],
        "4":["g","h","i"],
        "5":["j","k","l"],
        "6":["m","n","o"],
        "7":["p","q","r","s"],
        "8":["t","u","v"],
        "9":["w","x","y","z"]
    }
    if not digits:
        return []
    tmp = []
    result = []
    def backtrack(i):
        if i >= len(digits):
            result.append("".join(tmp))
            return
        for item in n_dict[digits[i]]:
            tmp.append(item)
            backtrack(i+1)
            tmp.pop()
    backtrack(0)
    return result
```

